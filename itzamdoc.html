<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Itzam - A Concise Embedded Database Engine in Standard C</title>

    <style type="text/css">
        p {
            font-family:   Trebuchet, Calibri, Arial, Helvetica, sans-serif;
            font-weight:   normal;
            font-style:    normal;
            font-size:     100%;
            line-height:   110%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   3.0em;
            margin-right:  0em;
            margin-top:    1.0em;
            margin-bottom: 0em;
            border-width:  0em;
            color:         #000000
        }

        p i      { font-style: italic; }
        p sub    { font-size: 60%; vertical-align: sub }
        p sup    { font-size: 60%; vertical-align: super }
        p em     { font-style: italic; }
        p b      { font-weight: bold; }
        p strong { font-weight: bold; }
        p big    { font-size: 115%; }
        p small  { font-size: 90%; }

        code
        {
            font:          Andale Mono, Freemono, monospace;
            font-size:     110%;
            line-height:   100%;
            color:         #8030FF;
        }

        pre
        {
            font-family:   monospace;
            font-style:    bold;
            font-size:     100%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   4.0em;
            margin-right:  4.0em;
            margin-top:    1.0em;
            margin-bottom: 0.5em;
            color:         #8030FF;
            background:    #F0F0F0
        }

        h1
        {
            font-family:   Trebuchet, Calibri, Arial, Helvetica, sans-serif;
            font-weight:   bold;
            font-style:    normal;
            font-size:     180%;
            line-height:   125%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   0em;
            margin-right:  0em;
            margin-top:    2.0em;
            margin-bottom: 0.0em;
            border-width:  0em;
            color:         #8030FF;
        }

        h2
        {
            font-family:   Trebuchet, Calibri, Arial, Helvetica, sans-serif;
            font-weight:   normal;
            font-style:    normal;
            font-size:     130%;
            line-height:   110%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   0em;
            margin-right:  0em;
            margin-top:    0.0em;
            margin-bottom: 2.0em;
            border-width:  0em;
            color:         #8030FF;
        }

        h3
        {
            font-family:   Trebuchet, Calibri, Arial, Helvetica, sans-serif;
            font-weight:   bold;
            font-style:    italic;
            font-size:     120%;
            line-height:   100%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   1.5em;
            margin-right:  0em;
            margin-top:    1.0em;
            margin-bottom: 1.0em;
            border-width:  0em;
            color:         #8030FF;
        }

        h4
        {
            font-family:   Trebuchet, Calibri, Arial, Helvetica, sans-serif;
            font-weight:   bold;
            font-style:    italic;
            font-size:     125%;
            text-indent:   0em;
            text-align:    left;
            margin-left:   0.2em;
            margin-right:  0em;
            margin-top:    1.0em;
            margin-bottom: 0.5em;
            color:         #8030FF;
            background:    #E8D8FF;
        }

    </style>
</head>

<body>

<!--#include virtual="/include/header.html" -->

<h1>Itzam</h1>
<h2>A Concise Embeddable Database Engine</i></h2>

<p>
Itzam manages data storage using B-tree indexes,
storing arbitrary records that are compared for sequence ordering and indexing. 
Keys are any user-defined segment of the record, and key-ordering is defined by the implementor.
</p><p>
Itzam supports
transactions with rollback, multiple threads accessing the same database, and other features not
usually found in small database engines.
</p><p>
In the real world, Itzam is the foundation of several business applications, including
mission-critical systems running 24/365.
</p><p>
Itzam is not a SQL database, or something that can be accessed from ADO.
You can build relational (or network, or...) database systems with Itzam as the
underlying mechanic &mdash; but that really isn&apos;t what Itzam was meant for. The vast majority
of applications do not need Oracle or SQL Server &mdash; they need a simple way to associate
information with a key value, for retrieval. This is the niche Itzam occupies.
</p>
<h4>History</h4>
<p>
Itzam has a long and varied history. It began as example code in my first book, <i>C++
Components and Algorithms</i> (1992). The original code was meant to teach C++, yet
several people contacted me asking if they could use it in various projects. Some even
offered to pay for the code.
</p><p>
And so I reworked the book code into something worthy of production code. After many
versions (and a side-trip into Java under the name &quot;Jisp&quot;), I arrived at the Itzam you
see today.
</p><p>
The current reference version is written in C for a variety of reasons. C produces
small code and can be wrapped in various other programming languages. By writing in
Standard C, I maintain portability. The current code has seen production and commercial
use across PCs, cell phones, and Macs.
</p><p>
As a summer 2016, Itzam has undergone a modernization to C11, and a conversion to 64-bits
only. 
</p><h4>
Why &quot;Itzam&quot;?
</h4><p>
Naming projects is always difficult; I sometimes think every word in English has been
appropriated by someone. So I've had to stretch my linguistic horizons. &quot;Itzam&quot;
is one of several Mayan words for <i>iguana</i>; given the fondness of iguanas for trees,
and the presence of an iguana in my house, the name seemed rather fitting.
</p><p>
The Itzam logo (and all other site art) was created by my eldest daughter Elora, using a
combination of commercial and open source tools.
</p><h4>
License
</h4><p>
I license Itzam under the FreeBSD License (aka, the Simplified
BSD License). It is as follows:
</p>

<pre>
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the
      above copyright notice, this list of conditions
      and the following disclaimer.

   2. Redistributions in binary form must reproduce the
      above copyright notice, this list of conditions and
      the following disclaimer in the documentation and/or
      other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY SCOTT ROBERT LADD ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL SCOTT ROBERT LADD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the author alone, and should not be interpreted as representing the official
policies, either expressed or implied, of anyoen other than Scott Robert Ladd.
</pre>
<p>
Older versions were released under various incarnations of the GPL. I won&apos;t bore you with
details of why I&apos;ve meandered through various Open Source/Free Software licenses; suffice
it to say that the balkanization and politics of the Free Software movement have rubbed
me very raw.
</p><p>
Individual and corporate licensing is available under a closed-source license; I also provide
maintenance contracts and custom development. For such matters, please contact me at
<a href="mailto:scott.ladd@gmail.com">scott.ladd@gmail.com</a>.
</p>

<h4>Basic Concepts and Structures</h4>
<p>
Most of the processes and concepts used in Itzam are the same as those used "under the
hood" by more complex database systems. Itzam is a nuts-and-bolts approach to database
development, providing great flexibility and customization at the expense of
abstraction. You define how data is connected and associated; such control
requires careful understanding of your data.
</p>
<p>
Itzam organizes objects serialized in files based on your definition of how records are compared.
Internally, Itzam stores records in B-tree structured files. In many respects, Itzam is very object-oriented,
with functions tied by name to target data structures in much the same way as a C++ program
links methods to class objects.
</p>
<p>
Everything you need is defined in the <code>itzam.h</code> header files. You'll find several data
structures and internal definitions inside; you can safely ignore most of this, since you'll
be working directly with only a few core types and structures.
</p>
<h3>itzam_ref (simple type)</h3>
<p>
  By default, an itzam_ref is the address (position) of information
  inside an Itzam-defined database. By default, Itzam uses 32-bit file
  pointers; defining the preprocessor macro ITZAM64 during compilation
  will create an Itzam library that uses 64-bit file pointers and 64-bit file
  operations, which allows access to files up to 9 <em>quintillion</em>
  bytes long.
<br><br>
  In general, <code>itzam_int</code> is simply a synonym for <code>itzam_ref</code>,
  reflecting different contexts. An <code>itzam_int</code> is a length or size,
  while and <code>itzam_ref</code> is a file reference (position).
</p>
<h3>itzam_status (enum)</h3>
<p>
Most Itzam functions return a status code, which can be set to <code>ITZAM_OKAY</code>, <code>ITZAM_NOT_FOUND</code>, or
any of the other constants found in <code>itzam.h</code>. Note that many functions will call an
error handler function for serious errors; <code>itzam_status</code> is designed for programatic
purpose (e.g., discovering that a key was not found), as opposed to error handling.
</p>
<h3>itzam_datafile (struct)</h3>
<p>
An <code>itzam_datafile</code> is a structured data file for storing fixed- or variable-length records;
it automatically writes new records in space freed by deleted records. This class is useful without
any of the indexing capabilities inherent in <code>itzam_btree</code>. In some applications, it may
be practical to store data in individual <code>itzam_datafile</code>s, indexing
it via one or more <code>itzam_btree</code>s.
</p>
<p>
For the purposes of an <code>itzam_datafile</code>, consider "record" to be nothing more than
a blob of binary data; the semantics of that "blob" is the province of your program. If you're
talking to Itzam from Java, for example, you can serialize objects to and from byte streams
stored in an <code>itzam_datafile</code>.
</p>
<p>
To handle variable-length records, <code>itzam_datafile</code> records the
size of each record. When a record is deleted, the space it occupied is marked as
empty. The file maintains a linked list of deleted record locations and their sizes.
</p>
<p>
Inserting a new record involves a traverse of the deleted list, looking for an empty
record that is large enough to contain the new information. If the deleted list is
empty, or the new record is too large to fit into any open slots, the new object
record is appended to the file.
</p>
<p>
Reusing deleted record space has a drawback: it leaves dead space in the file when
a newly-inserted record is smaller than the "deleted" space it overwrites. Deleted
records also use space in the file until a new record is written into their location.
If your record sizes vary widely, it may make sense to periodically compact the file
by removing the wasted space, eliminating deleted records, and regenerating indexes.
If your records are fixed-length, the data file shouldn't contain much waste space.
</p>
<p>
All functions that directly manipulate datafiles follow the naming pattern <code>itzam_datafile_*</code>.
</p>
<h3>itzam_btree (struct)</h3>
<p>
An <code>itzam_btree</code> organizes records with user-defined keys. A key is simply a pointer
into your record structure, with the programmer defining a relational function that compares the 
data at key pointer and returns a relational result. A B-tree structure stores records in an 
<code>itzam_datafile</code>. The actual content of the key is unrestricted. A key
could be a 32-bit numeric serial number and a 32- or 64-bit reference to the associated record,
or a string, or whatever.
</p>
<p>
All functions that directly manipulate B-tree indexes follow the naming pattern <code>itzam_btree_*</code>.
</p>
<h3>itzam_btree_cursor (struct)</h3>
<p>
An <code>itzam_btree_cursor</code> is a list of the records in a database, and can be traversed in key order.
It does not store records; instead, it is a forward and backward traversable list of records in
order (as defined by the database's key comparison function.)
</p>
<p>
When you create an <code>itzam_btree_cursor</code>, it locks the mutex for the B-tree, preventing changes
to that B-tree until the cursor is closed.
</p>
<p>
In many ways, an <code>itzam_btree_cursor</code> can be used like a traditional database cursor.
You can also treat it like a query, filtering records as you iterate through a list of records.
</p>
<p>
All functions that directly manipulate B-tree cursors follow the naming pattern <code>itzam_btree_cursor_*</code>.
</p>
<h4>Example Code</h4>
<p>
</p>
<p>
The primary documentation for Itzam are the sample programs in the <code>test</code> path. These programs 
illustrate the use of Itzam features in a variety of applications.
</p>
<h3>stress</h3>
<p>
This program performs a series of random inserts and removes from a B-tree index, verifying the
validity of the database after each action, and using transactions with commits and recalls. It
excercises almost every part of Itzam, and demonstrates how to use those features.
</p>
<p>
Itzam includes several test and example programs, found in the <i>test</i> directory of the distribution.
</p>
<h3>insert</h3>
<p>
Created at the behest of several customers, to show how fast raw insertion is. This is simple a
benchmark.
</p>
<h3>threads</h3>
<p>
This program creates multiple threads that sumltaneously insert and rmeove records from the
same B-tree index. Mutexes within Itzam control resource access, and shared memory
improves performance.
</p>
<h3>strvar</h3>
<p>
Here is an example of two oft-queried concepts: The use of variable-length string keys, and
the storage of variable-length records. For a simple Itzam
database of fixed-length records (as in the examples above), data can be embedded along with
keys in the B-tree structure. For more complex data bases, the key can be linked to a reference
to its asscoaited data -- in this case, an itzam_ref to a record stored independently with
the B-tree file.
</p><p>
This example also illustrates a key feature of Itzam: B-tree files are
also itzam_datafiles, <i>and</i> an itzam_btree index can reference data outside the B-tree
&mdash; for example, a position in another fiel that could contain text, other binary data,
or another itzam_datafile.
</p><p>
The B-tree cursor mechanism is also shown in this example.
</p>

<h3>Furthe Illuminations</h3>
<h4>Datafiles</h4>

<p>
An <code>itzam_datafile</code> is a structured data file for storing fixed- or variable-length records;
it automatically writes new records in space freed by deleted records. This class is useful without
any of the indexing capabilities inherent in <code>itzam_btree</code>. In some applications, it may
be practical to store data in individual <code>itzam_datafile</code>s, indexing
it via one or more <code>itzam_btree</code>s.
</p>
<p>
For the purposes of an <code>itzam_datafile</code>, consider "record" to be nothing more than
a blob of binary data; the semantics of that "blob" is the province of your program. If you're
talking to Itzam from Java, for example, you can serialize objects to and from byte streams
stored in an <code>itzam_datafile</code>.
</p>
<p>
To handle variable-length records, <code>itzam_datafile</code> records the
size of each record. When a record is deleted, the space it occupied is marked as
empty. The file maintains a linked list of deleted record locations and their sizes.
</p>
<p>
Inserting a new record involves a traverse of the deleted list, looking for an empty
record that is large enough to contain the new information. If the deleted list is
empty, or the new record is too large to fit into any open slots, the new object
record is appended to the file.
</p>
<p>
Reusing deleted record space has a drawback: it leaves dead space in the file when
a newly-inserted record is smaller than the "deleted" space it overwrites. Deleted
records also use space in the file until a new record is written into their location.
If your record sizes vary widely, it may make sense to periodically compact the file
by removing the wasted space, eliminating deleted records, and regenerating indexes.
If your records are fixed-length, the data file shouldn't contain much waste space.
</p>
<p>
All functions that directly manipulate datafiles follow the naming pattern <code>itzam_datafile_*</code>.
</p>

<h4>B-trees</h4>

<p>
The B-tree data structure maintains a list of keys in order, as determined by a user-supplied
key comparison function. You determine the sort order via the comparison function supplied when
opening or creating an <code>itzam_btree</code>. Just be certain that you always <i>use the same
comparison function whenever making changes to the index.</i>
</p>
<p>
All keys must be unique in a B-tree index.
</p>
<p>
Functions that directly manipulate B-tree indexes follow the naming pattern <code>itzam_btree_*</code>.
</p>

</body>
</html>